from __future__ import print_function
import numpy as np
import re
import math
import string
from gekko import GEKKO

# Global variables
spikeMap = {}
connectionMap = {}
# group to neuron mapping
groupMap = {}
# group to group mapping -> Key is the source group, value is a list of destination groups.
grpgrpMap = {}
groupGroupMap= {}
# group to spike mapping -> Map the spike times generated by a group only if the spikes are sent to another group
# internal spikes are ignored
groupSpikeMap = {}

itr = 0 
numNeurons = 500
numNeuronsPerCluster = 256
if numNeurons % numNeuronsPerCluster:
    numGroups = int(numNeurons/numNeuronsPerCluster) + 1
else:
    numGroups = int(numNeurons/numNeuronsPerCluster)

ISI = 0
spikeDisorder = 0
processedGroup = 0

def numberOfSpikes(srcNeuron, destNeuron): 
    # find the number of spikes communicated between two neurons.
    # the 2 neurons cannot belong to the same crossbar. 
    #print("SrcNeuron :" + str(srcNeuron))
    #print("DestNeuron :" + str(destNeuron))
    if srcNeuron in connectionMap:
        spikes = 0
        for i in connectionMap[srcNeuron]:
            if int(i) == destNeuron:
                spikes = len(spikeMap[srcNeuron])
                #print(srcNeuron, destNeuron, spikes)
                break
            else:
                spikes = 0
    else:
        spikes = 0
    
    #print(srcNeuron, destNeuron, spikes) 
    return spikes


def generateGroupInfo(x, i):
    itr = 0
    #groupMap.clear()
    global processedGroup
    #print(numGroups)
    for groupNumber in range(numGroups): 
        for itr, neuronNumber in enumerate(clusteredGroup):
            neuronItr = itr+groupNumber*numNeurons
            #print(neuronItr)
            #print(x[neuronItr].value[0]==1)
            #print(type(x[neuronItr].value))
            if x[neuronItr].value[0] == 1: 
                #print(neuronItr, groupNumber)
                if  processedGroup not in groupMap:
                    groupMap[processedGroup] = [neuronNumber]
                else:
                    groupMap[processedGroup].append(neuronNumber)
        processedGroup = processedGroup + 1
    
    print(groupMap)

    # Group -> Node mapping does not need to be generated as it is a one-one mapping at the moment
    # Generate Traffic.txt file. Contains spike time, source group ID. 
    # Generate ConnectionMap -> Source Group to Destination Group. 
def printInfo():  
    
    groupGroupMap.clear()
    groupSpikeMap.clear()
    # Generating connection_table.txt and traffic.txt
    trafficFile = open("partialTraffic.txt", 'w')
    connectionFile = open("partialConnectionTable.txt", 'w')
    for sourceGroup in range(processedGroup-1):
        for sourceNeuron in groupMap[sourceGroup]:
            if sourceNeuron in connectionMap:
                for destNeuron in connectionMap[sourceNeuron]:
                    if destNeuron not in groupMap[sourceGroup]:
                        # find the group number that the dest neuron belongs to
                        for destGroup in groupMap:
                            if destNeuron in groupMap[destGroup]:
                                if sourceGroup not in groupGroupMap: 
                                    groupGroupMap[sourceGroup] = [destGroup]
                                else:
                                    if destGroup not in groupGroupMap[sourceGroup]: 
                                        groupGroupMap[sourceGroup].append(destGroup)
                        if sourceNeuron in spikeMap:
                            if sourceGroup not in groupSpikeMap: 
                                groupSpikeMap[sourceGroup] = spikeMap[sourceNeuron]
                            #else:
                                #for spike in spikeMap[sourceNeuron]:
                                    #print(spike)
                                groupSpikeMap[sourceGroup].extend(spikeMap[sourceNeuron])
    
    
    for group in range(processedGroup-1):
        if group in groupSpikeMap:
            for spikeTime in groupSpikeMap[group]:
            # print timestamp --> source group number 
                trafficFile.write(str(spikeTime) + ' ' + str(group) + "\n")
    
    for group in range(processedGroup-1):
        if group in groupGroupMap:
            connectionFile.write(str(group) + ' ' + str(len(groupGroupMap[group])) + "\n")
            for destGroup in groupGroupMap[group]:
                connectionFile.write(str(destGroup) + ' ')

            connectionFile.write('\n')
            
    connectionFile.close()
    trafficFile.close()
    
    # Trigger Noxim with the generated traffic and connectionTable, the node mapping is still one to one.  


def readSpikeInfo(logFileLines): 
    itr = 0
    while itr in range(0,len(logFileLines)):
        line = logFileLines[itr]
        neuronNumber_re = re.compile('[0-9]+,[0-9]+', flags=0)
        neuronNumber = str(neuronNumber_re.search(line).group()).split(',')
        neuronNumber = int(neuronNumber.pop(0))
        
        itr = itr + 1
        line = logFileLines[itr]
        spikeTimes_re = re.compile('([0-9]+ )+', flags=0)
        if(spikeTimes_re.search(line)):
            spikeTimes = spikeTimes_re.search(line).group().split(' ')
            spikeTimes = spikeTimes
            spikeMap[neuronNumber] = spikeTimes 
        else:
            spikeMap[neuronNumber] = []

        itr = itr + 1 

    #for neuronNumber in spikeMap: 
       # print("Neuron Number: " + str(neuronNumber) + " SpikeTimes: " + str(spikeMap[neuronNumber]) )

########################### implementation added to target clustered nlip approach #################################3

def readIntermediateGroupInfo(groupFile, vectorptr): 
    itr = 0
    while itr in range(0, len(groupFile)):
        line = groupFile[itr]
        vectorptr.append(int(line))
        itr = itr + 1

########################################################################################################################

    

def readConnectionInfo(logFileLines):
    itr = 0 
    while itr in range(0, len(logFileLines)):
        line = logFileLines[itr]
        neuronNumber_re = re.compile('[0-9]+', flags=0)
        neuronNumber = str(neuronNumber_re.search(line).group())
        neuronNumber = int(neuronNumber)

        itr = itr + 1
        line = logFileLines[itr]
        connectedNeurons_re = re.compile('([0-9]+ )+', flags=0)
        if(connectedNeurons_re.search(line)):
            connectedNeurons = connectedNeurons_re.search(line).group().strip().split(' ')
            connectedNeurons = map(int, connectedNeurons)
            if neuronNumber in connectionMap:
                connectionMap[neuronNumber].extend(connectedNeurons)
            else:
                connectionMap[neuronNumber] = connectedNeurons
                    
        else:
            connectionMap[neuronNumber] = []

        itr = itr + 2 

    #for neuronNumber in connectionMap: 
        #print("Neuron Number: " + str(neuronNumber) + " Connections: " + str(connectionMap[neuronNumber]) )

# checks to see if two neurons are connected in a design
def isConnected(srcNeuron, destNeuron):
    if srcNeuron in connectionMap:
        if destNeuron in connectionMap[srcNeuron]:
            return 1
        else: 
            return 0
    else:
        return 0


def cons1(x, j):
    
    #each position in the constraints file shows if a particular constraint has been met. 
    # if the constraint value is greater than 0 then the constraint has been met. if not then the constraint has failed. 
    #caluclation for constraint number one.
    constraintOne = 0
    neuron = 0
    cluster = 0
    check = 0
    for i in range(numGroups):
        check = check + x[i*numNeurons+j]

    return check


def cons2(x, k):
    
    constraintTwo = 0
    check = 0
    for i in range(numNeurons):
        check = check + x[k*numNeurons + i]

    return check


 
def optimizationFunction1(x, srcCrossbar, srcItr, srcNeuron):    
    #finding the total number of spikes communicated between the crossbars.
    totalSpikeCount = 0
    spikeCount = 0

    totalSpikePerCrossbar = 0
     
    for a in range(1):
        for b in range(1):        
            for destCrossbar in range(numGroups):
                if destCrossbar != srcCrossbar:
                    for  destItr, destNeuron in enumerate(clusteredGroup):
                        #print(srcNeuron, destNeuron)
                        spikes = numberOfSpikes(srcNeuron,destNeuron)
                        if(spikes):
                            srcNeuron = srcItr
                            destNeuron = destItr
                            spikeCount += x[srcCrossbar*numNeurons+srcNeuron]*x[destNeuron+destCrossbar*numNeurons]*spikes
    #print(spikeCount)
    return spikeCount



#clusteredGroup = []

logFile = open('spikeTraffic.txt', 'r')
logFileLine = logFile.readlines()
readSpikeInfo(logFileLine)
logFile.close()
print("Spike Data Read")

logFile = open('connection_table.txt', 'r')
logFileLine = logFile.readlines()
readConnectionInfo(logFileLine)
logFile.close()
print("Connection Data Read")

for i in range(2): 
    clusteredGroup = []   
    logFile = open('group'+str(i)+'.txt', 'r')
    logFileLine = logFile.readlines()
    readIntermediateGroupInfo(logFileLine, clusteredGroup)

    numDimension = numNeurons * numGroups
    x = []
    m = GEKKO()

    m.options.SOLVER = 1 

# Create numDimension number of variables for the solver 
    for l in range(numDimension):
        x.append(m.Var(lb=0, ub=1, integer=True))

# constrain 1 - a neuron can only exist in one group 
    for j in range(numNeurons):
        m.Equation(cons1(x, j) == 1)

    for k in range(numGroups):
        m.Equation(cons2(x, k) < numNeuronsPerCluster)


    for srcCrossbar in range(numGroups):
        for srcItr, srcNeuron in enumerate(clusteredGroup): #numNeurons):
        #if(optimizationFunction(x, srcCrossbar, srcNeuron) is not 0):
            m.Obj(optimizationFunction1(x, srcCrossbar, srcItr, srcNeuron))

    m.solve()
    
    #for i in range(numGroups):
        #for j in range(numNeurons):
            #print('x' + str(j) + ' ' + str(x[i*numNeurons+j].value), end='')
    
        #print('')

    print(len(x))
    generateGroupInfo(x, i)

printInfo()

